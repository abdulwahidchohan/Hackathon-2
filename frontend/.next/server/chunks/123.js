"use strict";exports.id=123,exports.ids=[123],exports.modules={63123:(a,b,c)=>{c.d(b,{memoryAdapter:()=>f});var d=c(97960),e=c(48750);let f=(a,b)=>{let c=null,f=(0,e.II)({config:{adapterId:"memory",adapterName:"Memory Adapter",usePlural:!1,debugLogs:b?.debugLogs||!1,supportsArrays:!0,customTransformInput:b=>(b.options.advanced?.database?.useNumberId||b.options.advanced?.database?.generateId==="serial")&&"id"===b.field&&"create"===b.action?a[b.model].length+1:b.data,transaction:async b=>{let d=structuredClone(a);try{return await b(f(c))}catch(b){throw Object.keys(a).forEach(b=>{a[b]=d[b]}),b}}},adapter:({getFieldName:b,options:c,getModelName:e})=>{let f=(a,c,d)=>c?a.sort((a,e)=>{let f=b({model:d,field:c.field}),g=a[f],h=e[f],i=0;return i=null==g&&null==h?0:null==g?-1:null==h?1:"string"==typeof g&&"string"==typeof h?g.localeCompare(h):g instanceof Date&&h instanceof Date?g.getTime()-h.getTime():"number"==typeof g&&"number"==typeof h?g-h:"boolean"==typeof g&&"boolean"==typeof h?g===h?0:g?1:-1:String(g).localeCompare(String(h)),"asc"===c.direction?i:-i}):a;function g(b,c,f){let g=(b,c)=>{let e=a[c];if(!e)throw d.vF.error(`[MemoryAdapter] Model ${c} not found in the DB`,Object.keys(a)),Error(`Model ${c} not found`);let f=(a,b)=>{let{field:c,value:d,operator:e}=b;switch(e){case"in":if(!Array.isArray(d))throw Error("Value must be an array");return d.includes(a[c]);case"not_in":if(!Array.isArray(d))throw Error("Value must be an array");return!d.includes(a[c]);case"contains":return a[c].includes(d);case"starts_with":return a[c].startsWith(d);case"ends_with":return a[c].endsWith(d);case"ne":return a[c]!==d;case"gt":return null!=d&&a[c]>d;case"gte":return null!=d&&a[c]>=d;case"lt":return null!=d&&a[c]<d;case"lte":return null!=d&&a[c]<=d;default:return a[c]===d}};return e.filter(a=>{if(!b.length||0===b.length)return!0;let c=f(a,b[0]);for(let d of b){let b=f(a,d);c="OR"===d.connector?c||b:c&&b}return c})};if(!f)return g(b,c);let h=g(b,c),i=new Map,j=new Map;for(let b of h){let c=String(b.id);if(!i.has(c)){let a={...b};for(let[b,d]of Object.entries(f)){let f=e(b);"one-to-one"===d.relation?a[f]=null:(a[f]=[],j.set(`${c}-${b}`,new Set))}i.set(c,a)}let g=i.get(c);for(let[h,i]of Object.entries(f)){let f=e(h),k=a[f];if(!k)throw d.vF.error(`[MemoryAdapter] JoinOption model ${f} not found in the DB`,Object.keys(a)),Error(`JoinOption model ${f} not found`);let l=k.filter(a=>a[i.on.to]===b[i.on.from]);if("one-to-one"===i.relation)g[f]=l[0]||null;else{let a=j.get(`${c}-${h}`),b=i.limit??100,d=0;for(let c of l){if(d>=b)break;!a.has(c.id)&&(g[f].push(c),a.add(c.id),d++)}}}}return Array.from(i.values())}return{create:async({model:b,data:d})=>((c.advanced?.database?.useNumberId||c.advanced?.database?.generateId==="serial")&&(d.id=a[e(b)].length+1),a[b]||(a[b]=[]),a[b].push(d),d),findOne:async({model:a,where:b,join:c})=>{let d=g(b,a,c);return c?d.length?d[0]:null:d[0]||null},findMany:async({model:a,where:b,sortBy:c,limit:d,offset:e,join:h})=>{let i=g(b||[],a,h);if(h){if(!i.length)return[];f(i,c,a);let b=i;return void 0!==e&&(b=b.slice(e)),void 0!==d&&(b=b.slice(0,d)),b}let j=f(i,c,a);return void 0!==e&&(j=j.slice(e)),void 0!==d&&(j=j.slice(0,d)),j||[]},count:async({model:b,where:c})=>c?g(c,b).length:a[b].length,update:async({model:a,where:b,update:c})=>{let d=g(b,a);return d.forEach(a=>{Object.assign(a,c)}),d[0]||null},delete:async({model:b,where:c})=>{let d=a[b],e=g(c,b);a[b]=d.filter(a=>!e.includes(a))},deleteMany:async({model:b,where:c})=>{let d=a[b],e=g(c,b),f=0;return a[b]=d.filter(a=>e.includes(a)?(f++,!1):!e.includes(a)),f},updateMany({model:a,where:b,update:c}){let d=g(b,a);return d.forEach(a=>{Object.assign(a,c)}),d[0]||null}}}});return a=>(c=a,f(a))}}};